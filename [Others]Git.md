# Git 파헤치기

<img src="./img/thumbnail/github.png" width="100%"/>

## 들어가며
매일 업무를 시작하기 전에, `fetch`와 `pull`을 하고 소스를 올리기 위해 `push`를 하는 습관 속에서
문득 `명령어들 간의 차이가 무엇이지?` 라는 생각이 들어서 학습하게 되었다.

- Git 정의와 필요성
- 구조와 명령어
- 서브모듈 정의
- `Attached HEAD`와 `Detached HEAD`

## Git 정의와 필요성
Git은 **분산형 버전 관리 시스템**(**VCS**: Version Control System)으로 정의한다. 

사실 다른 사람이 Git이 무엇이냐고 물었을 때마다 "그냥 소스코드 관리하는 툴이야"라고 했었지만,   
Git은 코드 뿐만 아니라, `.txt` `.md`와 같은 텍스트 파일을 저장하고 관리할 수 있으므로 내가 정의한 내용은 사실상 틀린 내용이다.

이러한 Git이 **왜** 필요할까?

보통 하나의 서비스를 개발하는데 투입되는 인력은 여러명이다. 서비스 규모에 따라 투입되는 인력은 늘어날 수도 줄어들 수 도 있다.   
그럼 _한 명에서 서비스를 개발하는데 왜 굳이 Git을 써야해?_ 라는 의문을 가지는 사람도 있을 것이다.   
결론은 `써야한다` 그 이유는 `이력 관리`를 할 수 있기 때문이다.   
기업에 창업 멤버 혹은 초기 개발자가 몇 명이나 남아있을까?    
입사한지 3년차지만, 3년동안 퇴사한 개발자만 최소 5명은 넘었다.   
기존 개발자들이 작성한 소스 코드를 보면 '어떤 의도로 작성했는지' 파악하기 힘들 때 개인적으로 해당 소스 코드의 이력을 살펴본다.   
커밋 내용을 보면서 '어떤 부분을 수정했는지' 알 수 있고 수정 범위를 가늠할 수 있기 때문이다.
또한, 버그를 발견했을 때 이력을 확인하며 어떤 부분이 잘못되었는지 추론할 수 있다. 

이 외에도 Git을 사용해야 하는 필요성은 아래와 같다.
1. 협업하는 데 있어서 서로 같은 파일을 수정할 경우, 모든 수정사항을 유지할 수 있다.
2. 특정 시간에 기록한 버전을 되돌릴 수 있어서 코드 복원에 매우 유용하다.
3. `젠킨스`, `Github Action`과 같이 CI/CD를 쉽게 사용할 수 있다.
4. 오프라인 상태에서도 개발을 할 수 있다.

## 구조와 명령어
![깃 구조](img/Git%20Structure.png)

`clone`: 복제를 의미하며, 보통 원격 저장소에 있는 코드를 복제하여 로컬 저장소를 생성한다(= clone 뜬다 라고도 표현 함)   
`add` : 수정(변경)한 파일을 스테이지 영역(Staging)에 올림   
`commit`: 스테이지 영역에 있는 내용을 로컬 저장소에 기록함(스냅샷)   
`push`: 로컬 저장소에 있는 스냅샷을 원격 저장소에 업로드   
`pull`: 원격 저장소에 최신 커밋 내역을 내려 받아 현재 브랜치에 자동 병합 ( `pull` = `fetch` + `merge`)    
`fetch`: 원격 저장소에 있는 최신 커밋 내역을 내려 받아 `FETCH_HEAD` 파일에 가져옴(병합X)   
`reset`: 특정 커밋으로 `HEAD`를 이동, `Staging Area`에 있는 변경 사항을 취소, `Working Directory`의 변경 사항을 되돌림(로컬 상태에서 변경 사항을 되돌리는 명령어)   
`revert`: 원격 저장소에서 기존 커밋의 변경 사항을 되돌리는 새로운 커밋을 생성

## 서브모듈(Submodule)?
Git에서의 서브 모듈은 `Git 저장소(메인 저장소) 안에 다른 Git 저장소`로 정의한다.

현재 업무에서 사용하는 소스 코드에서도 메인 저장소(A)안에 공통 컴포넌트를 담고 있는 디렉토리(B)가 존재한다. _`A`안에 `B`가 있는 구조임_   
`.gitmodule` 파일을 확인하면 서브 모듈이 있는지 파악할 수 있다.

```gitmodule
// .gitmodule 예제
[submodule "code/Common"]
    path = code/Common
    url = 해당 깃 주소
```
 
이러한 환경에서 소스 코드를 반영하는 방법이 조금 낯설었다.   
서브모듈(B)를 수정하고 커밋 내역을 push 하면, 메인 저장소(A)에 커밋 이력이 자동으로 생성되고 이를 메인 저장소(A)에도 커밋 및 push를 해야 소스코드가 반영되었다.

그 이유를 분석해보니 `Attached HEAD`와 `Detached HEAD`의 개념에 대해 알게 되었고, `Detached HEAD`로 사용하고 있기에 해당 현상이 발생했다.


## `Attached HEAD`와 `Detached HEAD`?
Git에서 `HEAD`는 현재 작업중인 브랜치를 가리키는 포인터이다.
일반적으로 `HEAD`는 브랜치의 마지막 커밋을 가리키지만, 상황에 따라 특정 커밋을 직접 가리키는 경우가 있다.
이 상황을 각각 `Attached HEAD`, `Detached HEAD`로 정의된다.

### Attached HEAD
일반적이고 정상적인 상태이며, `HEAD`가 특정 브랜치(`main`)를 가리키는 것을 의미한다.

```shell
git checkout main
```
이때 `HEAD`는 `main` 브랜치를 가리킨다.(`HEAD` -> `main`)


### Detached HEAD
`HEAD`가 특정 커밋을 직접 가리키는 상태이다. 작업 내용을 변경해서 커밋을 하더라도 브랜치에 연결되지 않는다.

```shell
git checkout <커밋 해시값>
```
이때 `HEAD`는 커밋을 가리킨다.(`HEAD` -> `(커밋 해시)`) 

보통 서브모듈 환경에서는 `Detached HEAD` 방식을 사용하는 것은 아래 두가지 이유로 일반적인 방법이다.
1. 일관성 유지
2. 예상 가능한 빌드

물론, `커밋 고립`이나 `커밋이 보존되지 않는` 문제점도 존재한다.   
따라서 서브모듈에서 HEAD를 어떻게 구성할 지는 한번쯤 생각해봐야 할 것 같다.

## 참고 문서
- [Inpa Dev의 git 개념 & 원리(그림으로 알기 쉽게 비유)](https://inpa.tistory.com/entry/GIT-%E2%9A%A1%EF%B8%8F-%EA%B0%9C%EB%85%90-%EC%9B%90%EB%A6%AC-%EC%89%BD%EA%B2%8C%EC%9D%B4%ED%95%B4#git_%EC%9D%B4%EB%9E%80_%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80?)